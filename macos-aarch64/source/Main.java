/* autogenerated by Processing revision 1293 on 2024-12-10 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Main extends PApplet {

// declaring fields
private String[] monthArray = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};
private ArrayList<ArrayList<ArrayList<SongData>>> sortedSongs; // 3D ArrayList { Years { Months { Ranks } } }
private float panelWidth, panelHeight, xStart, yStart, phase;
private int[] position = {0, 0, 0}; // {year, month, rank} used to store the current position within the 3D ArrayList declared above.
private Wave currentWave;
private Frame body;

public void setup() {
  /* size commented out by preprocessor */;
  phase = 0;
  body = new Frame();
  // method calls:
  initSetup(); // initialises variables
  loadData(); // onloads and sorts data from CSV file
}

public void draw() {
  background(168, 158, 111);
  // using constrain to prevent incorrect input
  position[0] = constrain(position[0], 0, 63); // Years range from index 0 to 63, ensures no bad input
  position[1] = constrain(position[1], 0, 11); // Months range from index 0 to 11 (12 months)
  position[2] = constrain(position[2], 0, 14); // Ranks range from index 0 to 14, since there are 15 ranks
  // set wave to selected position
  SongData currentSong = sortedSongs.get(position[0]).get(position[1]).get(position[2]);
  body.draw();
  stroke(255, 50);
  line(xStart, panelHeight-410, panelWidth, panelHeight-410);
  noStroke();
  if (currentSong.date != null) {
    currentWave = new Wave(currentSong);
    currentWave.draw();
    body.controls[0].theta = ((float) 360/64) * position[0];
    body.controls[1].theta = body.controlsTheta[1] * position[1]; // if pos = 0. then 30 * 0 = 0, thus still at cirlce origin.
    body.controls[2].theta = body.controlsTheta[2] * position[2];
  } else {
    if (position[1] < 11) {
      position[1]++;
    } else {
      position[1]--;
    }
  }
}

public void keyPressed() {
  // Year navigation
  if (keyCode == UP) {
    if (position[0] < 63) {
      position[0]++;
    } else {
      position[0] = 0;
    }
  } else if (keyCode == DOWN) {
    if (position[0] > 0) {
      position[0]--;
    } else {
      position[0] = 63;
    }
  }
  // Month navigation
  if (keyCode == RIGHT) {
    if (position[1] != 11) {
      position[1]++;
    } else {
      position[1] = 0;
    }
  } else if (keyCode == LEFT) {
    if (position[1] != 0) {
      position[1]--;
    } else {
      position[1] = 11;
    }
  }
  // Rank navigation
  if (key == ' ') {
    if (position[2] != 14) {
      position[2]++;
    } else {
      position[2] = 0;
    }
  } else if (key == 'r') {
    position[0] = 0;
    position[1] = 0;
    position[2] = 0;
  }
}

private void initSetup() { // handles variable initialisation for sketch setup
  panelWidth = (width/2 + 800)+100;
  if (panelWidth >= width) {
    panelWidth = (width/3 + 800);
  }
  panelHeight = (height/2 + 400)+100;
  xStart = width - panelWidth;
  yStart = panelHeight-400;
}
class Frame {
  private float displayH = 400;
  private Knob[] controls = {new Knob(0), new Knob(1), new Knob(2)};
  private float[] controlsTheta = {(float) 360/24, (float) 360/12, (float) 360/15};

  private void draw() {
    // draw display bezels
    drawBezel(10, yStart-(displayH+10), panelHeight+10, color(115, 109, 99));
    drawBezel(0, yStart-displayH, panelHeight, color(20));
    // draw controls bezels
    drawBezel(10, 20, yStart-(displayH+30), color(115, 109, 99)); // draws outer bezel
    drawBezel(0, 30, yStart-(displayH+40), color(20)); // draws inner bezel
    drawControls(0);
    drawControls(1);
    drawControls(2);
  }

  private void drawControls(int index) {
    float[] pos = {0.25f, 0.5f, 0.75f};
    pushMatrix();
    translate(xStart*pos[index]+panelWidth*pos[index], dist(xStart, yStart-400, xStart, 10)/2);
    controls[index].draw();
    popMatrix();
  }

  private void drawBezel(float xOffset, float yOffset2, float yOffset1, int col) { // draws reactive bezels
    fill(col);
    beginShape();
    vertex(xStart-xOffset, yOffset1);
    vertex(xStart-xOffset, yOffset2);
    vertex(panelWidth+xOffset, yOffset2);
    vertex(panelWidth+xOffset, yOffset1);
    endShape(CLOSE); // using CLOSE automatically connects the last vertext to the first, :) you learn something new everyday
    noFill();
  }
}
class Knob {
  private float diameter = height*0.08f; // kinda reactive to screen size
  private float radius = diameter/2;
  private float theta = 0; // angle theta determines the angle of the knob
  private int KnobNumber;

  Knob(int KnobNumber) {
    this.KnobNumber = KnobNumber;
  }

  private void draw() {
    // drawing cirlce
    noStroke();
    fill(105, 105, 105);
    circle(0, 0, diameter);
    noFill();
    for (int i = 0; i < 360; i+=body.controlsTheta[KnobNumber]) {
      stickMarker(i, KnobNumber);
    }
    // drawing hand of instrument
    pushMatrix();
    rotate(radians(theta));// Rotate around the center of the knob
    hand(110, 70, color(128, 128, 128)); // origin of theta is 90 degrees right of the point
    hand(100, 80, color(192, 192, 192));
    popMatrix();
  }

  private void hand(float theta1, float theta2, int col) {
    beginShape();
    stroke(col);
    fill(col);
    vertex(0, -(radius-6));
    vertex(radius*cos(radians(theta1)), radius*sin(radians(theta1)));
    vertex(radius*cos(radians(theta2)), radius*sin(radians(theta2)));
    endShape(CLOSE);
    noStroke();
    noFill();
  }

  private void stickMarker(float theta, int index) {
    // rotating angle by -90 degrees to make origin point at the top of circle
    // calculate x,y start point and x,y end point
    float x1 = (radius+10)*cos(radians(theta-90));
    float x2 = (radius+20)*cos(radians(theta-90));
    float y1 = (radius+10)*sin(radians(theta-90));
    float y2 = (radius+20)*sin(radians(theta-90));
    // drawing stick marker
    if (index == 0 && theta % 45 == 0) {  // checks if this is year dial, theta should be a multiple of 45, since we are incrementing by 45 degrees. 
        alignPrintYear(theta, x2, y2); // the year dial needs extra attention since there are too many years
        stroke(255, 250, 250); // sub markers are darker and placed in else, main markers are lighter and more visible.
    } else {
      stroke(128, 128, 128);
    }
    line(x1, y1, x2, y2);
    noStroke();
    fill(192, 192, 192);
    if (index == 1) {
      alignPrintMonths(theta, x2, y2);
    } else if (index == 2) {
      alignPrintRank(theta, x2, y2);
    }
    // drawing month names
    noFill();
  }

  private void alignPrintYear(float theta, float x2, float y2) {
    if (theta > 0 && theta < 180) {
      textAlign(LEFT);
      x2+=2;
      y2+=2;
    } else if (theta == 0 || theta == 180) {
      textAlign(CENTER);
      x2 -= 1;
    } else {
      textAlign(RIGHT);
      x2-=4;
      y2+=2;
    }
    if (theta == 0) {
      y2 -= 4;
    } else if (theta == 90 || theta == 270) {
      y2+=2;
    } else if (theta == 180) {
      y2+=10;
    }
    fill(255, 250, 250);
    text(PApplet.parseInt(1958 + 8*(theta/45)), x2, y2); // calculates year using formula which gets segment (theta/45)
    noFill();
  }

  private void alignPrintMonths(float theta, float x2, float y2) {
    // aggrogate allign logic
    if (theta > 0 && theta < 180) {
      textAlign(LEFT);
      x2+=2;
    } else if (theta > 180 && theta < 360) {
      textAlign(RIGHT);
      x2-=3;
    } else {
      textAlign(CENTER);
      x2-=2;
      y2+=12;
    }
    // adjustments in aggrogate allignment
    if (theta == 0) {
      y2-=16;
    } else if ((theta > 90 && theta < 180) || (theta > 180 && theta < 270)) {
      y2+=9;
    } else if (theta == 90 || theta == 270) {
      y2+=3;
    }
    text(monthArray[PApplet.parseInt(theta/30)], x2, y2);
  }

  private void alignPrintRank(float theta, float x2, float y2) {
    // aggrogate allign
    if (theta > 0 && theta < 180) {
      textAlign(LEFT);
      x2 += 2;
    } else if (theta > 180 && theta < 360) {
      textAlign(RIGHT);
      x2-=3;
      y2-=2;
    } else {
      textAlign(CENTER);
      x2-=2;
      y2-=4;
    }
    if (theta > 72 && theta < 192) {
      x2 += 2;
      y2 += 5;
    } else if (theta > 168 && theta < 288) {
      y2 +=7;
    }
    text(PApplet.parseInt((theta+24)/24), x2, y2);
  }
}
class SongData {
  // field declaration
  private String date, song, artist;
  private int year, rank, month;
  // sub class initialiser (classes in processing are all treated as sub classes of the main pde file)
  SongData(String date, String song, String artist, int rank) {
    this.date = date;
    this.song = song;
    this.artist = artist;
    this.rank = rank-1;
    this.year = Integer.parseInt(date.substring(6, 10)); // dd-mm-yyyy
    this.month = Integer.parseInt(date.substring(3, 5))-1;
  }
  SongData() {
    this.date=null;
  }
}

private void loadData() {
  setArrayLists(); // sets up sortedSongs ArrayList to be populated
  Table data = loadTable(dataPath("charts.csv"), "header"); // saves CSV information to data
  for (TableRow row : data.rows()) {
    SongData song = new SongData( // creating a new itteration of SongData
      row.getString("dates"),
      row.getString("song"),
      row.getString("artist"),
      row.getInt("rank")
      );
    // sortings song into the sortedSongs ArrayList
    int yearIndex = song.year - 1958; // i.e 1959 would be at index 1 and 1958 at index 0
    if (yearIndex >= 0 && yearIndex < sortedSongs.size()) {
      sortedSongs.get(yearIndex).get(song.month).set(song.rank, song);
    }
  }
}

private void setArrayLists() {
  // intialising ArrayLists
  sortedSongs = new ArrayList<>();
  // Array { Years { Months { Ranks } } }
  for (int numYears = 0; numYears < 64; numYears++) {
    ArrayList<ArrayList<SongData>> yearList = new ArrayList<>();
    for (int numMonths = 0; numMonths < 12; numMonths++) {
      ArrayList<SongData> monthList = new ArrayList<>();
      for (int numRanks = 0; numRanks < 15; numRanks++) {
        SongData emptySong = new SongData();
        monthList.add(emptySong);// added empty song object to month list
      }
      yearList.add(monthList);
    }
    sortedSongs.add(yearList);
  }
}
class Wave {
  private float amplitude, waveLength, cycles, phaseSpeed;
  private int colour;
  private SongData song;

  Wave(SongData song) {
    updateWave(song);
  }

  private int[] rankColours = {
    color(255, 0, 0), // Bright red
    color(255, 64, 0), // Bright orange
    color(255, 128, 0), // Orange
    color(255, 192, 0), // Yellow-orange
    color(255, 255, 0), // Yellow
    color(192, 255, 0), // Yellow-green
    color(128, 255, 0), // Greenish-yellow
    color(0, 255, 0), // Green
    color(0, 255, 128), // Light green
    color(0, 255, 192), // Turquoise
    color(0, 192, 255), // Cyan
    color(0, 128, 255), // Blue
    color(0, 64, 255), // Indigo
    color(128, 0, 255), // Purple
    color(64, 0, 128) // Dark purple
  };

  private void updateWave(SongData data) {
    this.song = data;
    this.amplitude = map(data.song.length(), 0, 70, 0, 400);
    this.waveLength = map(data.artist.length(), 3, 30, 20, panelWidth/8);
    this.cycles = map(data.month, 0, 11, 1, 50);
    this.colour = rankColours[data.rank];
    this.phaseSpeed = map(data.year, 1958, 2021, 0.1f, 5.0f);
  }

  private void draw() {
    beginShape();
    stroke(this.colour);
    for (float x = xStart; x < panelWidth; x++) {
      float y = panelHeight-410 + this.amplitude * sin((x / this.waveLength) * 2 * PI * this.cycles + phase);
      vertex(x, y);
    }
    endShape();
    phase+=this.phaseSpeed;
    noStroke();
    fill(255);
    textAlign(LEFT);
    textSize(16);
    text(this.song.song + " - " + song.artist, xStart+10, panelHeight - 40);
    textSize(12);
    text("Year: " + song.year + " | Month: " + monthArray[position[1]] + " | Rank: " + (song.rank+1), xStart+10, panelHeight - 20);
    textAlign(RIGHT);
    text("SPACE: Rank | \u2191\u2193: Change year | \u2190\u2192: Change month | R: Reset", panelWidth - 10, panelHeight - 20); // arrows using unicode
    noFill();
  }
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#666666", "--stop-color=#cccccc", "Main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
